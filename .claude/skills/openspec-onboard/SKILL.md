---
name: openspec-onboard
description: OpenSpecのガイド付きオンボーディング - ナレーションと実際のコードベース作業を通じて完全なワークフローサイクルを体験。
license: MIT
compatibility: openspec CLIが必要。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

ユーザーの最初の完全なOpenSpecワークフローサイクルをガイドします。これは教育体験です - 各ステップを説明しながらユーザーのコードベースで実際の作業を行います。

---

## プリフライト

開始前に、OpenSpecが初期化されているか確認：

```bash
openspec status --json 2>&1 || echo "NOT_INITIALIZED"
```

**初期化されていない場合：**
> OpenSpecはこのプロジェクトでまだセットアップされていません。最初に`openspec init`を実行してから、`/opsx:onboard`に戻ってきてください。

初期化されていない場合はここで停止。

---

## フェーズ1: ウェルカム

表示：

```
## OpenSpecへようこそ！

アイデアから実装まで、完全な変更サイクルをガイドします - コードベースの実際のタスクを使用して。その過程で、実際にやりながらワークフローを学びます。

**やること：**
1. コードベースの小さな実際のタスクを選ぶ
2. 問題を簡単に探索
3. 変更を作成（作業のコンテナ）
4. アーティファクトを構築: proposal → specs → design → tasks
5. タスクを実装
6. 完了した変更をアーカイブ

**所要時間:** 約15-20分

取り組む何かを見つけることから始めましょう。
```

---

## フェーズ2: タスク選択

### コードベース分析

小さな改善の機会を求めてコードベースをスキャン。探すもの：

1. **TODO/FIXMEコメント** - コードファイル内の`TODO`、`FIXME`、`HACK`、`XXX`を検索
2. **不足しているエラーハンドリング** - エラーを飲み込む`catch`ブロック、try-catchなしの危険な操作
3. **テストのない関数** - `src/`とテストディレクトリを照合
4. **型の問題** - TypeScriptファイル内の`any`型（`: any`、`as any`）
5. **デバッグの残骸** - 非デバッグコード内の`console.log`、`console.debug`、`debugger`ステートメント
6. **不足しているバリデーション** - バリデーションなしのユーザー入力ハンドラ

最近のgitアクティビティも確認：
```bash
git log --oneline -10 2>/dev/null || echo "No git history"
```

### 提案を提示

分析から、3-4個の具体的な提案を提示：

```
## タスク候補

コードベースをスキャンした結果、良いスターターとなるタスクがいくつかあります：

**1. [最も有望なタスク]**
   場所: `src/path/to/file.ts:42`
   スコープ: 約1-2ファイル、約20-30行
   良い理由: [簡潔な理由]

**2. [2番目のタスク]**
   場所: `src/another/file.ts`
   スコープ: 約1ファイル、約15行
   良い理由: [簡潔な理由]

**3. [3番目のタスク]**
   場所: [場所]
   スコープ: [見積もり]
   良い理由: [簡潔な理由]

**4. 他に何か？**
   取り組みたいものを教えてください。

どのタスクに興味がありますか？（番号を選ぶか、自分のものを説明してください）
```

**何も見つからない場合:** ユーザーに何を構築したいか尋ねることにフォールバック：
> コードベースで明らかなクイックウィンが見つかりませんでした。追加または修正しようと思っていた小さなものは何ですか？

### スコープガードレール

ユーザーが大きすぎるもの（大規模な機能、数日の作業）を選んだり説明したりした場合：

```
それは価値のあるタスクですが、最初のOpenSpec実行には大きすぎるかもしれません。

ワークフローを学ぶには、小さい方が良いです - 実装の詳細で行き詰まることなく、完全なサイクルを見ることができます。

**オプション：**
1. **もっと小さくスライス** - [彼らのタスク]の最小の有用な部分は何ですか？たぶん[特定のスライス]だけ？
2. **他のものを選ぶ** - 他の提案の1つ、または別の小さなタスク？
3. **とにかくやる** - 本当にこれに取り組みたいなら、できます。ただ時間がかかることを理解してください。

何がいいですか？
```

ユーザーが主張すればオーバーライドを許可 - これはソフトガードレール。

---

## フェーズ3: 探索デモ

タスクが選択されたら、探索モードを簡単にデモ：

```
変更を作成する前に、**探索モード**を簡単に紹介します - 方向を決める前に問題を考え抜く方法です。
```

関連するコードを1-2分調査：
- 関係するファイルを読む
- 役立つならクイックASCII図を描く
- 考慮事項をメモ

```
## クイック探索

[あなたの簡潔な分析 - 見つけたもの、考慮事項]

┌─────────────────────────────────────────┐
│   [オプション: 役立つならASCII図]        │
└─────────────────────────────────────────┘

探索モード（`/opsx:explore`）はこの種の考え方のためのものです - 実装前に調査する。問題を考え抜く必要があるときはいつでも使えます。

では、作業を保持する変更を作成しましょう。
```

**一時停止** - 進む前にユーザーの確認を待つ。

---

## フェーズ4: 変更を作成

**説明：**
```
## 変更を作成

OpenSpecの「変更」は、作業に関するすべての思考と計画のコンテナです。`openspec/changes/<name>/`にあり、アーティファクト - proposal、specs、design、tasksを保持します。

タスク用に1つ作成しましょう。
```

**実行:** 導出されたケバブケース名で変更を作成：
```bash
openspec new change "<derived-name>"
```

**表示：**
```
作成: `openspec/changes/<name>/`

フォルダ構造:
```
openspec/changes/<name>/
├── proposal.md    ← なぜこれをするか（空、埋める）
├── design.md      ← どう構築するか（空）
├── specs/         ← 詳細な要件（空）
└── tasks.md       ← 実装チェックリスト（空）
```

では最初のアーティファクト - proposalを埋めましょう。
```

---

## フェーズ5: Proposal

**説明：**
```
## Proposal

proposalは**なぜ**この変更を行うのか、高レベルで**何**が含まれるかを捉えます。作業の「エレベーターピッチ」です。

タスクに基づいて1つ下書きします。
```

**実行:** proposalコンテンツを下書き（まだ保存しない）：

```
proposal下書きです：

---

## Why

[問題/機会を説明する1-2文]

## What Changes

[何が違うかの箇条書き]

## Capabilities

### New Capabilities
- `<capability-name>`: [簡潔な説明]

### Modified Capabilities
<!-- 既存の動作を変更する場合 -->

## Impact

- `src/path/to/file.ts`: [何が変わるか]
- [該当する場合は他のファイル]

---

これで意図を捉えていますか？保存前に調整できます。
```

**一時停止** - ユーザーの承認/フィードバックを待つ。

承認後、proposalを保存：
```bash
openspec instructions proposal --change "<name>" --json
```
次に`openspec/changes/<name>/proposal.md`にコンテンツを書き込む。

```
Proposalが保存されました。これは「なぜ」ドキュメントです - 理解が進化したらいつでも戻って改良できます。

次はspecsです。
```

---

## フェーズ6: Specs

**説明：**
```
## Specs

specsは**何**を構築するかを正確でテスト可能な用語で定義します。期待される動作を明確にする要件/シナリオフォーマットを使用します。

このような小さなタスクでは、1つのspecファイルだけで十分かもしれません。
```

**実行:** specファイルを作成：
```bash
mkdir -p openspec/changes/<name>/specs/<capability-name>
```

specコンテンツを下書き：

```
specです：

---

## ADDED Requirements

### Requirement: <名前>

<システムが何をすべきかの説明>

#### Scenario: <シナリオ名>

- **WHEN** <トリガー条件>
- **THEN** <期待される結果>
- **AND** <必要に応じて追加の結果>

---

このフォーマット - WHEN/THEN/AND - は要件をテスト可能にします。文字通りテストケースとして読めます。
```

`openspec/changes/<name>/specs/<capability>/spec.md`に保存。

---

## フェーズ7: Design

**説明：**
```
## Design

designは**どう**構築するかを捉えます - 技術的な決定、トレードオフ、アプローチ。

小さな変更では、これは簡潔かもしれません。それで大丈夫です - すべての変更に深いデザイン議論が必要なわけではありません。
```

**実行:** design.mdを下書き：

```
designです：

---

## Context

[現在の状態についての簡潔なコンテキスト]

## Goals / Non-Goals

**Goals:**
- [達成しようとしていること]

**Non-Goals:**
- [明示的にスコープ外のもの]

## Decisions

### Decision 1: [重要な決定]

[アプローチと理由の説明]

---

小さなタスクでは、これは過剰設計せずに重要な決定を捉えます。
```

`openspec/changes/<name>/design.md`に保存。

---

## フェーズ8: Tasks

**説明：**
```
## Tasks

最後に、作業を実装タスクに分解します - applyフェーズを駆動するチェックボックス。

これらは小さく、明確で、論理的な順序である必要があります。
```

**実行:** specsとdesignに基づいてタスクを生成：

```
実装タスクです：

---

## 1. [カテゴリまたはファイル]

- [ ] 1.1 [具体的なタスク]
- [ ] 1.2 [具体的なタスク]

## 2. Verify

- [ ] 2.1 [検証ステップ]

---

各チェックボックスはapplyフェーズでの作業単位になります。実装する準備はできましたか？
```

**一時停止** - ユーザーが実装の準備ができていることを確認するのを待つ。

`openspec/changes/<name>/tasks.md`に保存。

---

## フェーズ9: Apply（実装）

**説明：**
```
## 実装

では各タスクを実装し、進むにつれてチェックを付けていきます。各タスクをアナウンスし、時々specs/designがアプローチをどう導いたかをメモします。
```

**実行:** 各タスクについて：

1. アナウンス：「タスクNに取り組み中: [説明]」
2. コードベースに変更を実装
3. specs/designを自然に参照：「specはXと言っているので、Yをしています」
4. tasks.mdで完了をマーク：`- [ ]` → `- [x]`
5. 簡潔な状態：「✓ タスクN完了」

ナレーションは軽く保つ - すべてのコード行を過剰に説明しない。

すべてのタスク後：

```
## 実装完了

すべてのタスク完了：
- [x] タスク1
- [x] タスク2
- [x] ...

変更が実装されました！あと1ステップ - アーカイブしましょう。
```

---

## フェーズ10: アーカイブ

**説明：**
```
## アーカイブ

変更が完了したら、アーカイブします。これにより`openspec/changes/`から`openspec/changes/archive/YYYY-MM-DD-<name>/`に移動されます。

アーカイブされた変更はプロジェクトの決定履歴になります - 後でなぜそのように構築されたかを理解するために常に見つけることができます。
```

**実行:**
```bash
openspec archive "<name>"
```

**表示：**
```
アーカイブ先: `openspec/changes/archive/YYYY-MM-DD-<name>/`

変更はプロジェクトの履歴の一部になりました。コードはコードベースに、決定記録は保存されています。
```

---

## フェーズ11: 振り返りと次のステップ

```
## おめでとうございます！

完全なOpenSpecサイクルを完了しました：

1. **Explore** - 問題を考え抜いた
2. **New** - 変更コンテナを作成
3. **Proposal** - WHYを捉えた
4. **Specs** - WHATを詳細に定義
5. **Design** - HOWを決定
6. **Tasks** - ステップに分解
7. **Apply** - 作業を実装
8. **Archive** - 記録を保存

このリズムは任意のサイズの変更に使えます - 小さな修正でも大規模な機能でも。

---

## コマンドリファレンス

| コマンド | 何をするか |
|---------|-----------|
| `/opsx:explore` | 作業前/中に問題を考え抜く |
| `/opsx:new` | 新しい変更を開始、アーティファクトを順に進める |
| `/opsx:ff` | 早送り: すべてのアーティファクトを一度に作成 |
| `/opsx:continue` | 既存の変更の作業を続ける |
| `/opsx:apply` | 変更からタスクを実装 |
| `/opsx:verify` | 実装がアーティファクトと一致するか検証 |
| `/opsx:archive` | 完了した変更をアーカイブ |

---

## 次は？

実際に構築したいものに`/opsx:new`や`/opsx:ff`を試してください。リズムは掴めました！
```

---

## グレースフル終了処理

### ユーザーが途中で止めたい場合

ユーザーが止める必要がある、一時停止したい、または関心が薄れているように見える場合：

```
問題ありません！変更は`openspec/changes/<name>/`に保存されています。

後で中断したところから再開するには：
- `/opsx:continue <name>` - アーティファクト作成を再開
- `/opsx:apply <name>` - 実装にジャンプ（タスクがある場合）

作業は失われません。準備ができたらいつでも戻ってきてください。
```

プレッシャーをかけずに丁寧に終了。

### ユーザーがコマンドリファレンスだけ欲しい場合

ユーザーがコマンドを見たいだけ、またはチュートリアルをスキップしたいと言った場合：

```
## OpenSpecクイックリファレンス

| コマンド | 何をするか |
|---------|-----------|
| `/opsx:explore` | 問題を考え抜く（コード変更なし） |
| `/opsx:new <name>` | 新しい変更を開始、ステップバイステップ |
| `/opsx:ff <name>` | 早送り: すべてのアーティファクトを一度に |
| `/opsx:continue <name>` | 既存の変更を続ける |
| `/opsx:apply <name>` | タスクを実装 |
| `/opsx:verify <name>` | 実装を検証 |
| `/opsx:archive <name>` | 完了したらアーカイブ |

最初の変更を開始するには`/opsx:new`を、素早く進めたいなら`/opsx:ff`を試してください。
```

丁寧に終了。

---

## ガードレール

- 重要な移行で**説明 → 実行 → 表示 → 一時停止パターンに従う**（探索後、proposal下書き後、タスク後、アーカイブ後）
- 実装中は**ナレーションを軽く保つ** - 講義せずに教える
- 変更が小さくても**フェーズをスキップしない** - 目標はワークフローを教えること
- マークされたポイントで**確認を待つ**が、過度に一時停止しない
- **終了をグレースフルに処理** - ユーザーに続けるプレッシャーをかけない
- **実際のコードベースタスクを使用** - シミュレーションや偽の例を使わない
- **スコープを優しく調整** - 小さなタスクに導くがユーザーの選択を尊重
