---
name: openspec-apply-change
description: OpenSpec変更からタスクを実装。ユーザーが実装を開始、継続、またはタスクを進めたい場合に使用。
license: MIT
compatibility: openspec CLIが必要。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

OpenSpec変更からタスクを実装します。

**入力**: オプションで変更名を指定。省略した場合は会話のコンテキストから推測を試みます。曖昧または不明確な場合は、利用可能な変更を表示して選択を促す必要があります。

**手順**

1. **変更を選択**

   名前が指定されている場合はそれを使用。そうでない場合：
   - 会話のコンテキストでユーザーが変更に言及していれば推測
   - アクティブな変更が1つしかない場合は自動選択
   - 曖昧な場合は`openspec list --json`を実行して利用可能な変更を取得し、**AskUserQuestionツール**を使用してユーザーに選択させる

   常にアナウンス：「変更を使用: <name>」と上書き方法（例：`/opsx:apply <other>`）。

2. **状態を確認してスキーマを理解**
   ```bash
   openspec status --change "<name>" --json
   ```
   JSONをパースして理解：
   - `schemaName`: 使用中のワークフロー（例：「spec-driven」）
   - どのアーティファクトにタスクが含まれているか（spec-drivenでは通常「tasks」、他はstatusを確認）

3. **apply指示を取得**

   ```bash
   openspec instructions apply --change "<name>" --json
   ```

   返される内容：
   - コンテキストファイルのパス（スキーマによって異なる - proposal/specs/design/tasksまたはspec/tests/implementation/docs）
   - 進捗（合計、完了、残り）
   - タスクリストと状態
   - 現在の状態に基づく動的な指示

   **状態の処理:**
   - `state: "blocked"`（アーティファクトが不足）の場合：メッセージを表示し、openspec-continue-changeの使用を提案
   - `state: "all_done"`の場合：祝福し、アーカイブを提案
   - それ以外：実装に進む

4. **コンテキストファイルを読む**

   apply指示出力の`contextFiles`にリストされたファイルを読む。
   ファイルは使用中のスキーマによって異なる：
   - **spec-driven**: proposal、specs、design、tasks
   - 他のスキーマ: CLI出力のcontextFilesに従う

5. **現在の進捗を表示**

   表示内容：
   - 使用中のスキーマ
   - 進捗：「N/M タスク完了」
   - 残りタスクの概要
   - CLIからの動的な指示

6. **タスクを実装（完了またはブロックまでループ）**

   各保留中のタスクに対して：
   - どのタスクに取り組んでいるか表示
   - 必要なコード変更を行う
   - 変更は最小限に抑え、フォーカスを維持
   - タスクファイルでタスクを完了にマーク：`- [ ]` → `- [x]`
   - 次のタスクへ続行

   **一時停止する場合:**
   - タスクが不明確 → 明確化を求める
   - 実装が設計上の問題を明らかにした → アーティファクトの更新を提案
   - エラーまたはブロッカーが発生 → 報告してガイダンスを待つ
   - ユーザーが中断した

7. **完了または一時停止時、状態を表示**

   表示内容：
   - このセッションで完了したタスク
   - 全体の進捗：「N/M タスク完了」
   - すべて完了の場合：アーカイブを提案
   - 一時停止の場合：理由を説明してガイダンスを待つ

**実装中の出力**

```
## 実装中: <change-name> (スキーマ: <schema-name>)

タスク 3/7 に取り組み中: <タスクの説明>
[...実装中...]
✓ タスク完了

タスク 4/7 に取り組み中: <タスクの説明>
[...実装中...]
✓ タスク完了
```

**完了時の出力**

```
## 実装完了

**変更:** <change-name>
**スキーマ:** <schema-name>
**進捗:** 7/7 タスク完了 ✓

### このセッションで完了
- [x] タスク 1
- [x] タスク 2
...

すべてのタスクが完了しました！この変更をアーカイブする準備ができています。
```

**一時停止時の出力（問題発生）**

```
## 実装一時停止

**変更:** <change-name>
**スキーマ:** <schema-name>
**進捗:** 4/7 タスク完了

### 発生した問題
<問題の説明>

**オプション:**
1. <オプション 1>
2. <オプション 2>
3. 他のアプローチ

どうしますか？
```

**ガードレール**
- 完了またはブロックまでタスクを続行
- 開始前に必ずコンテキストファイルを読む（apply指示出力から）
- タスクが曖昧な場合は、実装前に一時停止して確認
- 実装が問題を明らかにした場合は、一時停止してアーティファクトの更新を提案
- コード変更は各タスクに対して最小限で範囲を限定
- 各タスク完了直後にタスクチェックボックスを更新
- エラー、ブロッカー、不明確な要件では一時停止 - 推測しない
- CLI出力のcontextFilesを使用し、特定のファイル名を仮定しない

**流動的ワークフロー統合**

このスキルは「変更に対するアクション」モデルをサポート：

- **いつでも呼び出し可能**: すべてのアーティファクト完了前（タスクがあれば）、部分的な実装後、他のアクションとインターリーブ
- **アーティファクト更新を許可**: 実装が設計上の問題を明らかにした場合、アーティファクトの更新を提案 - フェーズロックではなく、流動的に作業
