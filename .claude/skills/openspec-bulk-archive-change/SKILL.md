---
name: openspec-bulk-archive-change
description: 複数の完了した変更を一度にアーカイブ。複数の並行変更をアーカイブする際に使用。
license: MIT
compatibility: openspec CLIが必要。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

複数の完了した変更を一度にアーカイブします。

このスキルでは、コードベースをチェックして実際に何が実装されているかを判断することで、spec競合をインテリジェントに処理しながら変更を一括アーカイブできます。

**入力**: なし（選択を促す）

**手順**

1. **アクティブな変更を取得**

   `openspec list --json`を実行してすべてのアクティブな変更を取得。

   アクティブな変更がない場合は、ユーザーに通知して終了。

2. **変更の選択を促す**

   **AskUserQuestionツール**をマルチ選択で使用してユーザーに変更を選択させる：
   - 各変更をスキーマとともに表示
   - 「すべての変更」オプションを含める
   - 任意の数の選択を許可（1+は可能、2+が典型的なユースケース）

   **重要**: 自動選択しない。常にユーザーに選択させる。

3. **バッチ検証 - 選択されたすべての変更の状態を収集**

   選択された各変更について収集：

   a. **アーティファクト状態** - `openspec status --change "<name>" --json`を実行
      - `schemaName`と`artifacts`リストをパース
      - どのアーティファクトが`done`でどれが他の状態かをメモ

   b. **タスク完了** - `openspec/changes/<name>/tasks.md`を読む
      - `- [ ]`（未完了）と`- [x]`（完了）をカウント
      - タスクファイルがない場合は「タスクなし」としてメモ

   c. **デルタspecs** - `openspec/changes/<name>/specs/`ディレクトリを確認
      - どのcapability specsが存在するかリスト
      - 各specについて、要件名を抽出（`### Requirement: <name>`にマッチする行）

4. **spec競合を検出**

   `capability -> [それに触れる変更]`のマップを構築：

   ```
   auth -> [change-a, change-b]  <- 競合（2+の変更）
   api  -> [change-c]            <- OK（1つの変更のみ）
   ```

   2+の選択された変更が同じcapabilityのデルタspecを持つ場合に競合が存在。

5. **競合をエージェント的に解決**

   **各競合について**、コードベースを調査：

   a. **デルタspecを読む** - 各競合する変更から、それぞれが何を追加/変更すると主張しているか理解

   b. **コードベースを検索** - 実装の証拠を探す：
      - 各デルタspecの要件を実装するコードを探す
      - 関連するファイル、関数、テストを確認

   c. **解決を決定**：
      - 1つの変更のみが実際に実装されている場合 → そのspecを同期
      - 両方実装されている場合 → 時系列順に適用（古い方を先に、新しい方が上書き）
      - どちらも実装されていない場合 → spec同期をスキップ、ユーザーに警告

   d. **各競合の解決を記録**：
      - どの変更のspecを適用するか
      - どの順序で（両方の場合）
      - 理由（コードベースで見つかったもの）

6. **統合状態テーブルを表示**

   すべての変更を要約したテーブルを表示：

   ```
   | 変更                  | アーティファクト | タスク | Specs   | 競合       | 状態   |
   |----------------------|-----------------|--------|---------|-----------|--------|
   | schema-management    | 完了            | 5/5    | 2 デルタ | なし      | 準備完了 |
   | project-config       | 完了            | 3/3    | 1 デルタ | なし      | 準備完了 |
   | add-oauth            | 完了            | 4/4    | 1 デルタ | auth (!)  | 準備完了* |
   | add-verify-skill     | 1 残り          | 2/5    | なし    | なし      | 警告   |
   ```

   競合については、解決を表示：
   ```
   * 競合解決:
     - auth spec: add-oauthを適用してからadd-jwtを適用（両方実装済み、時系列順）
   ```

   未完了の変更については、警告を表示：
   ```
   警告:
   - add-verify-skill: 1つの未完了アーティファクト、3つの未完了タスク
   ```

7. **バッチ操作を確認**

   **AskUserQuestionツール**で1つの確認を使用：

   - 「N個の変更をアーカイブしますか？」と状態に基づくオプション
   - オプションに含まれる可能性があるもの：
     - 「すべてのN個の変更をアーカイブ」
     - 「準備完了のN個の変更のみアーカイブ（未完了をスキップ）」
     - 「キャンセル」

   未完了の変更がある場合、警告付きでアーカイブされることを明確にする。

8. **確認された各変更のアーカイブを実行**

   決定された順序で変更を処理（競合解決を尊重）：

   a. **specを同期** - デルタspecが存在する場合：
      - openspec-sync-specsアプローチ（エージェント駆動のインテリジェントマージ）を使用
      - 競合については、解決された順序で適用
      - 同期が行われたか追跡

   b. **アーカイブを実行**：
      ```bash
      mkdir -p openspec/changes/archive
      mv openspec/changes/<name> openspec/changes/archive/YYYY-MM-DD-<name>
      ```

   c. **各変更の結果を追跡**：
      - 成功：正常にアーカイブ
      - 失敗：アーカイブ中にエラー（エラーを記録）
      - スキップ：ユーザーがアーカイブしないことを選択（該当する場合）

9. **サマリーを表示**

   最終結果を表示：

   ```
   ## 一括アーカイブ完了

   3つの変更をアーカイブ:
   - schema-management-cli -> archive/2026-01-19-schema-management-cli/
   - project-config -> archive/2026-01-19-project-config/
   - add-oauth -> archive/2026-01-19-add-oauth/

   1つの変更をスキップ:
   - add-verify-skill (ユーザーが未完了のアーカイブを選択しなかった)

   Spec同期サマリー:
   - 4つのデルタspecをメインspecsに同期
   - 1つの競合を解決（auth: 両方を時系列順に適用）
   ```

   失敗がある場合：
   ```
   1つの変更が失敗:
   - some-change: アーカイブディレクトリが既に存在
   ```

**競合解決の例**

例1: 1つのみ実装済み
```
競合: specs/auth/spec.md が [add-oauth, add-jwt] に触れられている

add-oauthを確認:
- デルタが「OAuth Provider Integration」要件を追加
- コードベースを検索... OAuthフローを実装したsrc/auth/oauth.tsを発見

add-jwtを確認:
- デルタが「JWT Token Handling」要件を追加
- コードベースを検索... JWT実装が見つからない

解決: add-oauthのみ実装済み。add-oauthのspecのみを同期。
```

例2: 両方実装済み
```
競合: specs/api/spec.md が [add-rest-api, add-graphql] に触れられている

add-rest-api (2026-01-10作成)を確認:
- デルタが「REST Endpoints」要件を追加
- コードベースを検索... src/api/rest.tsを発見

add-graphql (2026-01-15作成)を確認:
- デルタが「GraphQL Schema」要件を追加
- コードベースを検索... src/api/graphql.tsを発見

解決: 両方実装済み。add-rest-apiのspecを先に適用し、
次にadd-graphqlのspecを適用（時系列順、新しい方が優先）。
```

**成功時の出力**

```
## 一括アーカイブ完了

N個の変更をアーカイブ:
- <change-1> -> archive/YYYY-MM-DD-<change-1>/
- <change-2> -> archive/YYYY-MM-DD-<change-2>/

Spec同期サマリー:
- N個のデルタspecをメインspecsに同期
- 競合なし（または: M個の競合を解決）
```

**部分成功時の出力**

```
## 一括アーカイブ完了（部分）

N個の変更をアーカイブ:
- <change-1> -> archive/YYYY-MM-DD-<change-1>/

M個の変更をスキップ:
- <change-2> (ユーザーが未完了のアーカイブを選択しなかった)

K個の変更が失敗:
- <change-3>: アーカイブディレクトリが既に存在
```

**変更がない場合の出力**

```
## アーカイブする変更がありません

アクティブな変更が見つかりません。`/opsx:new`を使用して新しい変更を作成してください。
```

**ガードレール**
- 任意の数の変更を許可（1+は可能、2+が典型的なユースケース）
- 常に選択を促す、自動選択しない
- spec競合を早期に検出し、コードベースを確認して解決
- 両方の変更が実装されている場合、時系列順にspecを適用
- 実装がない場合のみspec同期をスキップ（ユーザーに警告）
- 確認前に明確な変更ごとの状態を表示
- バッチ全体に対して1つの確認を使用
- すべての結果を追跡して報告（成功/スキップ/失敗）
- アーカイブに移動する際に.openspec.yamlを保持
- アーカイブディレクトリのターゲットは現在の日付を使用: YYYY-MM-DD-<name>
- アーカイブターゲットが存在する場合、その変更は失敗するが他は続行
