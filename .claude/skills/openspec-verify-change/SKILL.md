---
name: openspec-verify-change
description: 実装が変更アーティファクトと一致するか検証。ユーザーがアーカイブ前に実装が完全、正確、一貫しているか確認したい場合に使用。
license: MIT
compatibility: openspec CLIが必要。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

実装が変更アーティファクト（specs、tasks、design）と一致するか検証します。

**入力**: オプションで変更名を指定。省略した場合は会話のコンテキストから推測を試みます。曖昧または不明確な場合は、利用可能な変更を表示して選択を促す必要があります。

**手順**

1. **変更名が指定されていない場合、選択を促す**

   `openspec list --json`を実行して利用可能な変更を取得。**AskUserQuestionツール**を使用してユーザーに選択させる。

   実装タスクがある変更を表示（tasksアーティファクトが存在）。
   各変更で使用されているスキーマが利用可能な場合は表示。
   未完了タスクがある変更は「（進行中）」としてマーク。

   **重要**: 変更を推測または自動選択しない。常にユーザーに選択させる。

2. **状態を確認してスキーマを理解**
   ```bash
   openspec status --change "<name>" --json
   ```
   JSONをパースして理解：
   - `schemaName`: 使用中のワークフロー（例：「spec-driven」）
   - この変更にどのアーティファクトが存在するか

3. **変更ディレクトリを取得しアーティファクトをロード**

   ```bash
   openspec instructions apply --change "<name>" --json
   ```

   これにより変更ディレクトリとコンテキストファイルが返される。`contextFiles`から利用可能なすべてのアーティファクトを読む。

4. **検証レポート構造を初期化**

   3つの次元を持つレポート構造を作成：
   - **完全性**: タスクとspecカバレッジを追跡
   - **正確性**: 要件実装とシナリオカバレッジを追跡
   - **一貫性**: デザイン遵守とパターン一貫性を追跡

   各次元にはCRITICAL、WARNING、SUGGESTIONの問題がありうる。

5. **完全性を検証**

   **タスク完了**:
   - contextFilesにtasks.mdが存在する場合、読む
   - チェックボックスをパース：`- [ ]`（未完了）vs `- [x]`（完了）
   - 完了vs合計タスクをカウント
   - 未完了タスクがある場合：
     - 各未完了タスクにCRITICAL問題を追加
     - 推奨：「タスクを完了: <説明>」または「既に実装されていれば完了としてマーク」

   **Specカバレッジ**:
   - `openspec/changes/<name>/specs/`にデルタspecsが存在する場合：
     - すべての要件を抽出（「### Requirement:」でマーク）
     - 各要件について：
       - 要件に関連するキーワードでコードベースを検索
       - 実装が存在する可能性があるか評価
     - 要件が未実装のように見える場合：
       - CRITICAL問題を追加：「要件が見つからない: <要件名>」
       - 推奨：「要件Xを実装: <説明>」

6. **正確性を検証**

   **要件実装マッピング**:
   - デルタspecsの各要件について：
     - 実装の証拠をコードベースで検索
     - 見つかった場合、ファイルパスと行範囲をメモ
     - 実装が要件の意図と一致するか評価
     - 乖離が検出された場合：
       - WARNING追加：「実装がspecから乖離している可能性: <詳細>」
       - 推奨：「<ファイル>:<行>を要件Xと照合して確認」

   **シナリオカバレッジ**:
   - デルタspecsの各シナリオについて（「#### Scenario:」でマーク）：
     - 条件がコードで処理されているか確認
     - シナリオをカバーするテストが存在するか確認
     - シナリオがカバーされていないように見える場合：
       - WARNING追加：「シナリオがカバーされていない: <シナリオ名>」
       - 推奨：「シナリオのテストまたは実装を追加: <説明>」

7. **一貫性を検証**

   **デザイン遵守**:
   - contextFilesにdesign.mdが存在する場合：
     - 重要な決定を抽出（「Decision:」、「Approach:」、「Architecture:」のようなセクションを探す）
     - 実装がそれらの決定に従っているか確認
     - 矛盾が検出された場合：
       - WARNING追加：「デザイン決定に従っていない: <決定>」
       - 推奨：「実装を更新するか、現実に合わせてdesign.mdを修正」
   - design.mdがない場合：デザイン遵守チェックをスキップ、「検証するdesign.mdがない」とメモ

   **コードパターン一貫性**:
   - 新しいコードをプロジェクトパターンとの一貫性でレビュー
   - ファイル命名、ディレクトリ構造、コーディングスタイルを確認
   - 重大な逸脱が見つかった場合：
     - SUGGESTION追加：「コードパターンの逸脱: <詳細>」
     - 推奨：「プロジェクトパターンに従うことを検討: <例>」

8. **検証レポートを生成**

   **サマリースコアカード**:
   ```
   ## 検証レポート: <change-name>

   ### サマリー
   | 次元       | 状態              |
   |-----------|------------------|
   | 完全性    | X/Y タスク、N要件 |
   | 正確性    | M/N 要件カバー    |
   | 一貫性    | 遵守/問題あり     |
   ```

   **優先度別の問題**:

   1. **CRITICAL**（アーカイブ前に修正必須）：
      - 未完了タスク
      - 不足している要件実装
      - それぞれに具体的でアクション可能な推奨

   2. **WARNING**（修正すべき）：
      - Spec/デザインの乖離
      - 不足しているシナリオカバレッジ
      - それぞれに具体的な推奨

   3. **SUGGESTION**（修正すると良い）：
      - パターンの不整合
      - 軽微な改善
      - それぞれに具体的な推奨

   **最終評価**:
   - CRITICAL問題がある場合：「X個のcritical問題が見つかりました。アーカイブ前に修正してください。」
   - warningのみの場合：「critical問題なし。Y個のwarningを検討してください。アーカイブ可能です（指摘された改善点あり）。」
   - すべてクリアの場合：「すべてのチェックに合格。アーカイブ準備完了。」

**検証ヒューリスティック**

- **完全性**: 客観的なチェックリスト項目に焦点（チェックボックス、要件リスト）
- **正確性**: キーワード検索、ファイルパス分析、合理的な推論を使用 - 完全な確実性は不要
- **一貫性**: 明らかな不整合を探す、スタイルを細かく指摘しない
- **偽陽性**: 不確かな場合、CRITICALよりWARNING、WARNINGよりSUGGESTIONを優先
- **アクション可能性**: すべての問題には該当する場合ファイル/行参照を含む具体的な推奨が必要

**グレースフルデグレード**

- tasks.mdのみ存在する場合：タスク完了のみ検証、spec/デザインチェックをスキップ
- tasks + specsが存在する場合：完全性と正確性を検証、デザインをスキップ
- フルアーティファクトがある場合：3つの次元すべてを検証
- どのチェックがスキップされ、なぜかを常にメモ

**出力フォーマット**

明確なmarkdownを使用：
- サマリースコアカードにテーブル
- 問題のグループ化リスト（CRITICAL/WARNING/SUGGESTION）
- フォーマット`file.ts:123`でのコード参照
- 具体的でアクション可能な推奨
- 「確認を検討」のような曖昧な提案は避ける
