---
name: openspec-continue-change
description: 次のアーティファクトを作成してOpenSpec変更の作業を続行。ユーザーが変更を進めたい、次のアーティファクトを作成したい、またはワークフローを続けたい場合に使用。
license: MIT
compatibility: openspec CLIが必要。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.0.2"
---

次のアーティファクトを作成して変更の作業を続行します。

**入力**: オプションで変更名を指定。省略した場合は会話のコンテキストから推測を試みます。曖昧または不明確な場合は、利用可能な変更を表示して選択を促す必要があります。

**手順**

1. **変更名が指定されていない場合、選択を促す**

   `openspec list --json`を実行して最終更新日順にソートされた利用可能な変更を取得。次に**AskUserQuestionツール**を使用してユーザーにどの変更で作業するか選択させる。

   最近更新された上位3-4件の変更をオプションとして表示：
   - 変更名
   - スキーマ（`schema`フィールドがある場合はそれを使用、なければ「spec-driven」）
   - 状態（例：「0/5 タスク」、「完了」、「タスクなし」）
   - 最終更新日（`lastModified`フィールドから）

   最近更新された変更を「（推奨）」としてマーク（ユーザーが続けたいものである可能性が高いため）。

   **重要**: 変更を推測または自動選択しない。常にユーザーに選択させる。

2. **現在の状態を確認**
   ```bash
   openspec status --change "<name>" --json
   ```
   JSONをパースして現在の状態を理解。レスポンスに含まれるもの：
   - `schemaName`: 使用中のワークフロースキーマ（例：「spec-driven」）
   - `artifacts`: アーティファクトの配列とその状態（「done」、「ready」、「blocked」）
   - `isComplete`: すべてのアーティファクトが完了しているかを示すブール値

3. **状態に基づいて行動**：

   ---

   **すべてのアーティファクトが完了している場合（`isComplete: true`）**：
   - ユーザーを祝福
   - 使用したスキーマを含む最終状態を表示
   - 提案：「すべてのアーティファクトが作成されました！この変更を実装するかアーカイブできます。」
   - 終了

   ---

   **作成準備ができているアーティファクトがある場合**（状態に`status: "ready"`のアーティファクトがある）：
   - 状態出力から`status: "ready"`の**最初の**アーティファクトを選択
   - その指示を取得：
     ```bash
     openspec instructions <artifact-id> --change "<name>" --json
     ```
   - JSONをパース。主要なフィールド：
     - `context`: プロジェクトの背景（あなたへの制約 - 出力に含めない）
     - `rules`: アーティファクト固有のルール（あなたへの制約 - 出力に含めない）
     - `template`: 出力ファイルに使用する構造
     - `instruction`: スキーマ固有のガイダンス
     - `outputPath`: アーティファクトを書き込む場所
     - `dependencies`: コンテキストのために読む完了済みアーティファクト
   - **アーティファクトファイルを作成**：
     - コンテキストのために完了済みの依存ファイルを読む
     - `template`を構造として使用 - そのセクションを埋める
     - 書く際に`context`と`rules`を制約として適用 - ただしファイルにはコピーしない
     - 指示で指定された出力パスに書き込む
   - 何が作成され、何がアンロックされたかを表示
   - **1つ**のアーティファクトを作成した後に終了

   ---

   **準備ができているアーティファクトがない場合（すべてブロック）**：
   - 有効なスキーマでは起こらないはず
   - 状態を表示し、問題の確認を提案

4. **アーティファクト作成後、進捗を表示**
   ```bash
   openspec status --change "<name>"
   ```

**出力**

各呼び出し後に表示：
- どのアーティファクトが作成されたか
- 使用中のスキーマワークフロー
- 現在の進捗（N/M完了）
- 今アンロックされたアーティファクト
- プロンプト：「続けますか？続行を依頼するか、次に何をするか教えてください。」

**アーティファクト作成ガイドライン**

アーティファクトの種類とその目的はスキーマによって異なります。何を作成するかを理解するには、instructions出力の`instruction`フィールドを使用してください。

一般的なアーティファクトパターン：

**spec-drivenスキーマ**（proposal → specs → design → tasks）：
- **proposal.md**: 変更が不明確な場合はユーザーに質問。Why、What Changes、Capabilities、Impactを埋める。
  - Capabilitiesセクションは重要 - リストされた各capabilityにはspecファイルが必要。
- **specs/<capability>/spec.md**: proposalのCapabilitiesセクションにリストされた各capabilityごとに1つのspecを作成（変更名ではなくcapability名を使用）。
- **design.md**: 技術的な決定、アーキテクチャ、実装アプローチをドキュメント化。
- **tasks.md**: 実装をチェックボックス付きタスクに分解。

他のスキーマについては、CLI出力の`instruction`フィールドに従ってください。

**ガードレール**
- 呼び出しごとに**1つ**のアーティファクトを作成
- 新しいものを作成する前に常に依存アーティファクトを読む
- アーティファクトをスキップしたり順序を変えて作成しない
- コンテキストが不明確な場合は、作成前にユーザーに確認
- 進捗をマークする前にアーティファクトファイルが存在することを確認
- スキーマのアーティファクトシーケンスを使用し、特定のアーティファクト名を仮定しない
- **重要**: `context`と`rules`は**あなた**への制約であり、ファイルのコンテンツではない
  - `<context>`、`<rules>`、`<project_context>`ブロックをアーティファクトにコピーしない
  - これらは何を書くかをガイドするが、出力に表示されるべきではない
