---
name: "OPSX: 一括アーカイブ"
description: 複数の完了した変更を一度にアーカイブ
category: Workflow
tags: [workflow, archive, experimental, bulk]
---

複数の完了した変更を一度にアーカイブします。

このスキルでは変更をバッチアーカイブでき、コードベースを確認して実際に実装されているものを判断することでspecコンフリクトをインテリジェントに処理します。

**入力**: なし（選択を促します）

**手順**

1. **アクティブな変更を取得**

   `openspec list --json`を実行してすべてのアクティブな変更を取得。

   アクティブな変更がない場合、ユーザーに通知して停止。

2. **変更選択を促す**

   **AskUserQuestionツール**をマルチセレクトで使用してユーザーに変更を選択させる：
   - 各変更をスキーマとともに表示
   - 「すべての変更」オプションを含める
   - 任意の数の選択を許可（1+でOK、2+が典型的なユースケース）

   **重要**: 自動選択しない。必ずユーザーに選択させる。

3. **バッチ検証 - 選択されたすべての変更の状態を収集**

   選択された各変更に対して収集：

   a. **アーティファクト状態** - `openspec status --change "<name>" --json`を実行
      - `schemaName`と`artifacts`リストをパース
      - どのアーティファクトが`done`で他の状態かをメモ

   b. **タスク完了** - `openspec/changes/<name>/tasks.md`を読む
      - `- [ ]`（未完了）vs `- [x]`（完了）をカウント
      - タスクファイルがない場合、「タスクなし」とメモ

   c. **デルタspecs** - `openspec/changes/<name>/specs/`ディレクトリを確認
      - どの機能specsが存在するかリスト
      - それぞれについて要件名を抽出（`### Requirement: <name>`に一致する行）

4. **specコンフリクトを検出**

   `capability -> [それに触れる変更]`のマップを構築：

   ```
   auth -> [change-a, change-b]  <- コンフリクト（2+変更）
   api  -> [change-c]            <- OK（1変更のみ）
   ```

   2つ以上の選択された変更が同じ機能のデルタspecsを持っている場合にコンフリクトが存在。

5. **コンフリクトをエージェント的に解決**

   **各コンフリクトに対して**、コードベースを調査：

   a. **デルタspecsを読む** - 各コンフリクト変更から、それぞれが追加/変更を主張する内容を理解

   b. **コードベースを検索** - 実装の証拠を探す：
      - 各デルタspecの要件を実装するコードを探す
      - 関連するファイル、関数、テストを確認

   c. **解決を決定**：
      - 1つの変更のみ実装されている → そのspecsを同期
      - 両方実装されている → 時系列順に適用（古い方が先、新しい方が上書き）
      - どちらも実装されていない → spec同期をスキップ、ユーザーに警告

   d. **各コンフリクトの解決を記録**：
      - どの変更のspecsを適用するか
      - どの順序で（両方の場合）
      - 根拠（コードベースで見つかったもの）

6. **統合状態テーブルを表示**

   すべての変更をまとめたテーブルを表示：

   ```
   | 変更                 | アーティファクト | タスク | Specs   | コンフリクト | 状態   |
   |---------------------|-----------------|--------|---------|-------------|--------|
   | schema-management   | 完了            | 5/5    | 2 delta | なし        | 準備完了|
   | project-config      | 完了            | 3/3    | 1 delta | なし        | 準備完了|
   | add-oauth           | 完了            | 4/4    | 1 delta | auth (!)    | 準備完了*|
   | add-verify-skill    | 1 残り          | 2/5    | なし    | なし        | 警告   |
   ```

   コンフリクトについては解決を表示：
   ```
   * コンフリクト解決:
     - auth spec: add-oauthを適用後、add-jwt（両方実装済み、時系列順）
   ```

   未完了変更については警告を表示：
   ```
   警告:
   - add-verify-skill: 1件の未完了アーティファクト、3件の未完了タスク
   ```

7. **バッチ操作を確認**

   **AskUserQuestionツール**で単一の確認：

   - 「N件の変更をアーカイブしますか？」と状態に基づくオプション
   - オプションの例：
     - 「すべてN件の変更をアーカイブ」
     - 「準備完了のN件のみアーカイブ（未完了をスキップ）」
     - 「キャンセル」

   未完了変更がある場合、警告付きでアーカイブされることを明確に。

8. **確認された各変更に対してアーカイブを実行**

   決定された順序で変更を処理（コンフリクト解決を尊重）：

   a. **specsを同期** - デルタspecsがある場合：
      - openspec-sync-specsアプローチを使用（エージェント駆動のインテリジェントマージ）
      - コンフリクトは解決された順序で適用
      - 同期されたかを追跡

   b. **アーカイブを実行**：
      ```bash
      mkdir -p openspec/changes/archive
      mv openspec/changes/<name> openspec/changes/archive/YYYY-MM-DD-<name>
      ```

   c. **各変更の結果を追跡**：
      - 成功：正常にアーカイブ
      - 失敗：アーカイブ中にエラー（エラーを記録）
      - スキップ：ユーザーがアーカイブしないことを選択（該当する場合）

9. **サマリーを表示**

   最終結果を表示：

   ```
   ## 一括アーカイブ完了

   N件の変更をアーカイブ:
   - schema-management-cli -> archive/2026-01-19-schema-management-cli/
   - project-config -> archive/2026-01-19-project-config/
   - add-oauth -> archive/2026-01-19-add-oauth/

   M件の変更をスキップ:
   - add-verify-skill（ユーザーが未完了をアーカイブしないことを選択）

   Spec同期サマリー:
   - 4件のデルタspecsをメインspecsに同期
   - 1件のコンフリクトを解決（auth: 両方を時系列順に適用）
   ```

   失敗がある場合：
   ```
   K件の変更が失敗:
   - some-change: アーカイブディレクトリが既に存在
   ```

**コンフリクト解決の例**

例1: 1つのみ実装
```
コンフリクト: specs/auth/spec.md が [add-oauth, add-jwt] で変更
add-oauthを確認:
- デルタは「OAuthプロバイダー統合」要件を追加
- コードベースを検索... src/auth/oauth.tsでOAuthフローの実装を発見

add-jwtを確認:
- デルタは「JWTトークン処理」要件を追加
- コードベースを検索... JWT実装が見つからない

解決: add-oauthのみ実装されている。add-oauthのspecsのみを同期。
```

例2: 両方実装
```
コンフリクト: specs/api/spec.md が [add-rest-api, add-graphql] で変更
add-rest-api（2026-01-10作成）を確認:
- デルタは「RESTエンドポイント」要件を追加
- コードベースを検索... src/api/rest.tsを発見

add-graphql（2026-01-15作成）を確認:
- デルタは「GraphQLスキーマ」要件を追加
- コードベースを検索... src/api/graphql.tsを発見

解決: 両方実装されている。add-rest-apiのspecsを先に適用、
次にadd-graphqlのspecs（時系列順、新しい方が優先）。
```

**成功時の出力**

```
## 一括アーカイブ完了

N件の変更をアーカイブ:
- <change-1> -> archive/YYYY-MM-DD-<change-1>/
- <change-2> -> archive/YYYY-MM-DD-<change-2>/

Spec同期サマリー:
- N件のデルタspecsをメインspecsに同期
- コンフリクトなし（または: M件のコンフリクトを解決）
```

**部分的成功時の出力**

```
## 一括アーカイブ完了（部分的）

N件の変更をアーカイブ:
- <change-1> -> archive/YYYY-MM-DD-<change-1>/

M件の変更をスキップ:
- <change-2>（ユーザーが未完了をアーカイブしないことを選択）

K件の変更が失敗:
- <change-3>: アーカイブディレクトリが既に存在
```

**変更がない場合の出力**

```
## アーカイブする変更がありません

アクティブな変更が見つかりません。`/opsx:new`で新しい変更を作成してください。
```

**ガードレール**
- 任意の数の変更を許可（1+でOK、2+が典型的なユースケース）
- 常に選択を促す、自動選択しない
- specコンフリクトを早期に検出しコードベースを確認して解決
- 両方の変更が実装されている場合、時系列順にspecsを適用
- 実装がない場合のみspec同期をスキップ（ユーザーに警告）
- 確認前に変更ごとの明確な状態を表示
- バッチ全体に対して単一の確認を使用
- すべての結果を追跡して報告（成功/スキップ/失敗）
- アーカイブに移動する際.openspec.yamlを保持
- アーカイブディレクトリのターゲットは現在の日付を使用：YYYY-MM-DD-<name>
- アーカイブターゲットが存在する場合、その変更は失敗させるが他は続行
