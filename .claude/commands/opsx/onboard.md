---
name: "OPSX: オンボーディング"
description: ガイド付きオンボーディング - ナレーションと実際のコードベース作業を通じて完全なOpenSpecワークフローサイクルを体験
category: Workflow
tags: [workflow, onboarding, tutorial, learning]
---

ユーザーを最初の完全なOpenSpecワークフローサイクルを通じてガイドします。これは教育体験です—各ステップを説明しながら、実際のコードベースで作業を行います。

---

## プリフライト

開始前にOpenSpecが初期化されているか確認：

```bash
openspec status --json 2>&1 || echo "NOT_INITIALIZED"
```

**初期化されていない場合:**
> OpenSpecはこのプロジェクトでまだセットアップされていません。まず`openspec init`を実行してから、`/opsx:onboard`に戻ってください。

初期化されていない場合はここで停止。

---

## フェーズ1: ウェルカム

表示：

```
## OpenSpecへようこそ！

アイデアから実装まで、完全な変更サイクルを、あなたのコードベースの実際のタスクを使って一緒に歩んでいきます。その過程で、実践しながらワークフローを学びます。

**やること:**
1. コードベースの小さな実際のタスクを選ぶ
2. 問題を簡単に探索
3. 変更を作成（作業のコンテナ）
4. アーティファクトを構築: proposal → specs → design → tasks
5. タスクを実装
6. 完了した変更をアーカイブ

それでは、取り組むものを見つけましょう。
```

---

## フェーズ2: タスク選択

### コードベース分析

小さな改善機会を探してコードベースをスキャン。探すもの：

1. **TODO/FIXMEコメント** - コードファイルで`TODO`、`FIXME`、`HACK`、`XXX`を検索
2. **エラー処理の欠如** - エラーを飲み込む`catch`ブロック、try-catchなしのリスクのある操作
3. **テストのない関数** - `src/`とテストディレクトリを相互参照
4. **型の問題** - TypeScriptファイルの`any`型（`: any`、`as any`）
5. **デバッグの残骸** - 非デバッグコードでの`console.log`、`console.debug`、`debugger`文
6. **バリデーションの欠如** - バリデーションのないユーザー入力ハンドラー

最近のgitアクティビティも確認：
```bash
git log --oneline -10 2>/dev/null || echo "No git history"
```

### 提案を提示

分析から3-4個の具体的な提案を提示：

```
## タスク候補

コードベースをスキャンした結果、以下が良いスタータータスクです：

**1. [最も有望なタスク]**
   場所: `src/path/to/file.ts:42`
   範囲: ~1-2ファイル、~20-30行
   良い理由: [簡潔な理由]

**2. [2番目のタスク]**
   場所: `src/another/file.ts`
   範囲: ~1ファイル、~15行
   良い理由: [簡潔な理由]

**3. [3番目のタスク]**
   場所: [場所]
   範囲: [見積もり]
   良い理由: [簡潔な理由]

**4. 別のもの？**
   取り組みたいものを教えてください。

どのタスクに興味がありますか？（番号を選ぶか、自分のものを説明）
```

**何も見つからない場合:** ユーザーに何を構築したいか尋ねるフォールバック：
> コードベースで明らかなクイックウィンが見つかりませんでした。追加または修正したい小さなものは何かありますか？

### スコープガードレール

ユーザーが大きすぎるものを選んだり説明した場合（主要機能、複数日の作業）：

```
それは価値のあるタスクですが、最初のOpenSpec体験としては大きすぎるかもしれません。

ワークフローを学ぶには、小さい方が良いです—実装の詳細に詰まることなく、完全なサイクルを見ることができます。

**オプション:**
1. **より小さく切る** - [そのタスク]の最小の有用な部分は？たぶん[具体的なスライス]だけ？
2. **別のものを選ぶ** - 他の提案の1つか、別の小さなタスク？
3. **とにかくやる** - どうしてもこれに取り組みたいなら、できます。ただ時間がかかることを知っておいてください。

どうしますか？
```

ユーザーが主張するならオーバーライドさせる—これはソフトガードレール。

---

## フェーズ3: 探索デモ

タスクが選択されたら、探索モードを簡単にデモ：

```
変更を作成する前に、**探索モード**を簡単に見せましょう—方向を決める前に問題を考え抜く方法です。
```

関連するコードを1-2分調査：
- 関係するファイルを読む
- 役立つ場合は簡単なASCIIダイアグラムを描く
- 考慮事項をメモ

```
## クイック探索

[簡単な分析—見つけたもの、考慮事項]

┌─────────────────────────────────────────┐
│   [オプション: 役立つ場合ASCIIダイアグラム] │
└─────────────────────────────────────────┘

探索モード（`/opsx:explore`）はこのような思考のためのものです—実装前に調査する。問題を考え抜く必要があるときいつでも使えます。

では、作業を保持する変更を作成しましょう。
```

**一時停止** - 続行前にユーザーの確認を待つ。

---

## フェーズ4: 変更の作成

**説明:**
```
## 変更の作成

OpenSpecの「変更」は、作業に関するすべての思考と計画のコンテナです。`openspec/changes/<name>/`に存在し、アーティファクト—proposal、specs、design、tasksを保持します。

タスク用に1つ作成しましょう。
```

**実行:** 導出されたケバブケース名で変更を作成：
```bash
openspec new change "<derived-name>"
```

**表示:**
```
作成: `openspec/changes/<name>/`

フォルダ構造:
openspec/changes/<name>/
├── proposal.md    ← なぜこれをするか（空、記入する）
├── design.md      ← どう構築するか（空）
├── specs/         ← 詳細な要件（空）
└── tasks.md       ← 実装チェックリスト（空）

では、最初のアーティファクト—proposalを記入しましょう。
```

---

## フェーズ5: Proposal

**説明:**
```
## Proposal

proposalはこの変更を**なぜ**行うのか、**何を**含むのかを高レベルで捉えます。作業の「エレベーターピッチ」です。

タスクに基づいて1つ下書きします。
```

**実行:** proposal内容を下書き（まだ保存しない）：

```
proposalの下書きです：

---

## なぜ

[問題/機会を説明する1-2文]

## 何が変わるか

[何が変わるかの箇条書き]

## 機能

### 新しい機能
- `<capability-name>`: [簡潔な説明]

### 変更される機能
<!-- 既存の動作を変更する場合 -->

## 影響

- `src/path/to/file.ts`: [何が変わるか]
- [該当する場合他のファイル]

---

これで意図を捉えていますか？保存前に調整できます。
```

**一時停止** - ユーザーの承認/フィードバックを待つ。

承認後、proposalを保存：
```bash
openspec instructions proposal --change "<name>" --json
```
次に`openspec/changes/<name>/proposal.md`に内容を書き込む。

```
Proposalを保存しました。これは「なぜ」ドキュメントです—理解が進むにつれていつでも戻って改善できます。

次: specs。
```

---

## フェーズ6: Specs

**説明:**
```
## Specs

Specsは**何を**構築するかを正確でテスト可能な用語で定義します。期待される動作を明確にする要件/シナリオ形式を使用します。

このような小さなタスクでは、1つのspecファイルだけで十分かもしれません。
```

**実行:** specファイルを作成：
```bash
mkdir -p openspec/changes/<name>/specs/<capability-name>
```

spec内容を下書き：

```
specです：

---

## ADDED Requirements

### Requirement: <名前>

<システムが何をすべきかの説明>

#### Scenario: <シナリオ名>

- **WHEN** <トリガー条件>
- **THEN** <期待される結果>
- **AND** <必要に応じて追加の結果>

---

この形式—WHEN/THEN/AND—は要件をテスト可能にします。文字通りテストケースとして読めます。
```

`openspec/changes/<name>/specs/<capability>/spec.md`に保存。

---

## フェーズ7: Design

**説明:**
```
## Design

designは**どう**構築するかを捉えます—技術的決定、トレードオフ、アプローチ。

小さな変更では、簡潔かもしれません。それで構いません—すべての変更に深い設計議論が必要なわけではありません。
```

**実行:** design.mdを下書き：

```
designです：

---

## コンテキスト

[現在の状態についての簡潔なコンテキスト]

## ゴール / ノンゴール

**ゴール:**
- [達成しようとしていること]

**ノンゴール:**
- [明示的にスコープ外のもの]

## 決定

### 決定1: [主要な決定]

[アプローチと根拠の説明]

---

小さなタスクでは、これで過剰設計なしに主要な決定を捉えます。
```

`openspec/changes/<name>/design.md`に保存。

---

## フェーズ8: Tasks

**説明:**
```
## Tasks

最後に、作業を実装タスクに分解します—applyフェーズを駆動するチェックボックス。

これらは小さく、明確で、論理的な順序であるべきです。
```

**実行:** specsとdesignに基づいてタスクを生成：

```
実装タスクです：

---

## 1. [カテゴリまたはファイル]

- [ ] 1.1 [具体的なタスク]
- [ ] 1.2 [具体的なタスク]

## 2. 検証

- [ ] 2.1 [検証ステップ]

---

各チェックボックスはapplyフェーズの作業単位になります。実装する準備はできましたか？
```

**一時停止** - ユーザーが実装の準備ができたことを確認するのを待つ。

`openspec/changes/<name>/tasks.md`に保存。

---

## フェーズ9: Apply（実装）

**説明:**
```
## 実装

各タスクを実装し、完了したらチェックを付けていきます。各タスクをアナウンスし、時々specs/designがアプローチにどう影響したかをメモします。
```

**実行:** 各タスクに対して：

1. アナウンス：「タスクNに取り組み中: [説明]」
2. コードベースで変更を実装
3. 自然にspecs/designを参照：「specにXとあるので、Yをしています」
4. tasks.mdで完了をマーク：`- [ ]` → `- [x]`
5. 簡潔なステータス：「✓ タスクN完了」

ナレーションは軽く—コードの各行を過度に説明しない。

すべてのタスク後：

```
## 実装完了

すべてのタスク完了:
- [x] タスク1
- [x] タスク2
- [x] ...

変更が実装されました！あと1ステップ—アーカイブしましょう。
```

---

## フェーズ10: アーカイブ

**説明:**
```
## アーカイブ

変更が完了したら、アーカイブします。これにより`openspec/changes/`から`openspec/changes/archive/YYYY-MM-DD-<name>/`に移動します。

アーカイブされた変更はプロジェクトの決定履歴になります—なぜ何かがそのように構築されたかを理解するために後でいつでも見つけることができます。
```

**実行:**
```bash
openspec archive "<name>"
```

**表示:**
```
アーカイブ先: `openspec/changes/archive/YYYY-MM-DD-<name>/`

変更はプロジェクトの履歴の一部になりました。コードはコードベースに、決定記録は保存されています。
```

---

## フェーズ11: 振り返りと次のステップ

```
## おめでとうございます！

完全なOpenSpecサイクルを完了しました：

1. **Explore** - 問題を考え抜いた
2. **New** - 変更コンテナを作成
3. **Proposal** - WHYを捉えた
4. **Specs** - WHATを詳細に定義
5. **Design** - HOWを決定
6. **Tasks** - ステップに分解
7. **Apply** - 作業を実装
8. **Archive** - 記録を保存

このリズムはどんなサイズの変更にも機能します—小さな修正から主要機能まで。

---

## コマンドリファレンス

| コマンド | 機能 |
|---------|------|
| `/opsx:explore` | 作業前/中に問題を考え抜く |
| `/opsx:new` | 新しい変更を開始、アーティファクトを段階的に |
| `/opsx:ff` | 一括作成: すべてのアーティファクトを一度に |
| `/opsx:continue` | 既存の変更の作業を続ける |
| `/opsx:apply` | 変更からタスクを実装 |
| `/opsx:verify` | 実装がアーティファクトと一致するか検証 |
| `/opsx:archive` | 完了した変更をアーカイブ |

---

## 次は？

実際に構築したいもので`/opsx:new`または`/opsx:ff`を試してください。リズムは掴めましたね！
```

---

## グレースフルな終了処理

### ユーザーが途中で止めたい場合

ユーザーが止める必要がある、一時停止したい、または関心がなさそうな場合：

```
問題ありません！変更は`openspec/changes/<name>/`に保存されています。

後で中断したところから再開するには:
- `/opsx:continue <name>` - アーティファクト作成を再開
- `/opsx:apply <name>` - 実装にジャンプ（タスクがある場合）

作業は失われません。準備ができたらいつでも戻ってきてください。
```

圧力なくグレースフルに終了。

### ユーザーがコマンドリファレンスだけを欲しい場合

ユーザーがコマンドを見たいだけ、またはチュートリアルをスキップしたいと言った場合：

```
## OpenSpecクイックリファレンス

| コマンド | 機能 |
|---------|------|
| `/opsx:explore` | 問題を考え抜く（コード変更なし） |
| `/opsx:new <name>` | 新しい変更を開始、段階的に |
| `/opsx:ff <name>` | 一括作成: すべてのアーティファクトを一度に |
| `/opsx:continue <name>` | 既存の変更を続ける |
| `/opsx:apply <name>` | タスクを実装 |
| `/opsx:verify <name>` | 実装を検証 |
| `/opsx:archive <name>` | 完了時にアーカイブ |

最初の変更を始めるには`/opsx:new`を、速く進めたいなら`/opsx:ff`を試してください。
```

グレースフルに終了。

---

## ガードレール

- **EXPLAIN → DO → SHOW → PAUSEパターンに従う** - 主要な遷移時（探索後、proposal下書き後、タスク後、アーカイブ後）
- **実装中はナレーションを軽く** - 講義せずに教える
- **フェーズをスキップしない** - 変更が小さくても—目標はワークフローを教えること
- **マークされたポイントで確認のために一時停止** - でも過度に一時停止しない
- **終了をグレースフルに処理** - ユーザーに続行を強制しない
- **実際のコードベースタスクを使用** - シミュレートしたり偽の例を使わない
- **スコープを穏やかに調整** - 小さなタスクに誘導するがユーザーの選択を尊重
